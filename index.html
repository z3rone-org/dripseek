<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>DripSeek</title>
  <style>
    body {
      font-family: sans-serif;
      margin: 0;
      padding: 0;
    }
    #canvasContainer {
      position: relative;
      width: 100%;
      height: 80vh;
      border: 2px dashed #aaa;
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
    }
    canvas {
      max-width: 100%;
      max-height: 100%;
      border: 1px solid #ccc;
    }
    .controls {
      margin: 10px;
    }
    .circle, .inner-circle {
      position: absolute;
      border-radius: 50%;
      background: transparent;
      pointer-events: none;
    }
    .circle {
      border: 2px solid red;
    }
    .inner-circle {
      border: 2px solid blue;
    }
  </style>
</head>
<body>

<div>
  1) Upload an image via the file selector, drag 'n drop or copy/paste.<br>
  2) Create the desired grid using the controls.<br>
  3) Resize the selection circles via +/- keys, resize the inner exclusion circles using K/L keys. Move all circles with the arrow keys and single circles via drag/drop.<br>
  4) Export the mean gray as a Python/JS array in the text box and as Excel compatible text in the clipboard.
</div>

<div class="controls">
  <input type="file" id="fileInput">
  <label>m: <input type="number" id="rows" value="3" min="1"></label>
  <label>n: <input type="number" id="cols" value="3" min="1"></label>
  <button onclick="createGrid()">Create Grid</button>
  <button onclick="showGrayLevels()">Mean Gray</button>
</div>

<div id="canvasContainer"
     ondragover="event.preventDefault()"
     ondrop="handleDrop(event)">
  <canvas id="canvas"></canvas>
</div>

<div class="controls">
  <label>Mean grayscale matrix:</label><br>
  <textarea id="grayOutput" rows="6" readonly></textarea>
</div>

<script>
let img = new Image();
let circles = [];
let radius = 20;
let innerRadius = 15;
let draggingCircle = null;
let offsetX, offsetY;

const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");
const container = document.getElementById("canvasContainer");

function resizeCanvasToImage() {
  canvas.width = img.width;
  canvas.height = img.height;
  container.style.width = img.width + "px";
  container.style.height = img.height + "px";
}

function drawImage() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.drawImage(img, 0, 0);
}

function clearCircles() {
  circles.flat().forEach(c => {
    c.outer.el.remove();
    c.inner.el.remove();
  });
  circles = [];
}

function createGrid() {
  clearCircles();
  drawImage();
  const m = parseInt(document.getElementById("rows").value);
  const n = parseInt(document.getElementById("cols").value);
  const spacingX = canvas.width / (n + 1);
  const spacingY = canvas.height / (m + 1);

  for (let i = 0; i < m; i++) {
    circles.push([]);
    for (let j = 0; j < n; j++) {
      const x = (j + 1) * spacingX;
      const y = (i + 1) * spacingY;

      const outer = document.createElement("div");
      outer.className = "circle";
      outer.style.width = outer.style.height = radius * 2 + "px";
      outer.style.left = (x - radius) + "px";
      outer.style.top = (y - radius) + "px";
      outer.style.cursor = "grab";
      outer.style.pointerEvents = "auto";
      container.appendChild(outer);

      const inner = document.createElement("div");
      inner.className = "inner-circle";
      inner.style.width = innerRadius * 2 + "px";
      inner.style.height = innerRadius * 2 + "px";
      inner.style.left = (x - innerRadius) + "px";
      inner.style.top = (y - innerRadius) + "px";
      container.appendChild(inner);

      makeDraggable(outer, inner);

      circles[i].push({ x, y, outer: { el: outer }, inner: inner });
    }
  }
}

function makeDraggable(outerEl, innerEl) {
  outerEl.onmousedown = (e) => {
    draggingCircle = outerEl;
    offsetX = e.offsetX;
    offsetY = e.offsetY;
    outerEl.style.cursor = "grabbing";

    document.onmousemove = (e) => {
      const rect = container.getBoundingClientRect();
      const newX = e.clientX - rect.left - offsetX;
      const newY = e.clientY - rect.top - offsetY;
      outerEl.style.left = newX + "px";
      outerEl.style.top = newY + "px";

      const x = newX + radius;
      const y = newY + radius;

      innerEl.style.left = (x - innerRadius) + "px";
      innerEl.style.top = (y - innerRadius) + "px";

      updateCirclePosition(e.target);
    };

    document.onmouseup = () => {
      document.onmousemove = null;
      draggingCircle = null;
      outerEl.style.cursor = "grab";
    };
  };
}

function updateCirclePosition(el) {
  for (let i = 0; i < circles.length; i++) {
    for (let j = 0; j < circles[i].length; j++) {
      if (circles[i][j].outer.el === el) {
        circles[i][j].x = parseInt(el.style.left) + radius;
        circles[i][j].y = parseInt(el.style.top) + radius;
      }
    }
  }
}

document.addEventListener("keydown", (e) => {
  const keys = ["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight", "+", "-", "k", "l"];
  if (keys.includes(e.key)) {
    e.preventDefault();
    if (e.key === "ArrowUp") moveCircles(0, -5);
    if (e.key === "ArrowDown") moveCircles(0, 5);
    if (e.key === "ArrowLeft") moveCircles(-5, 0);
    if (e.key === "ArrowRight") moveCircles(5, 0);
    if (e.key === "+") resizeCircles(1.1);
    if (e.key === "-") resizeCircles(0.9);
    if (e.key === "k") resizeInnerCircles(1.1);
    if (e.key === "l") resizeInnerCircles(0.9);
  }
});

function moveCircles(dx, dy) {
  circles.flat().forEach(c => {
    c.x += dx;
    c.y += dy;
    c.outer.el.style.left = (c.x - radius) + "px";
    c.outer.el.style.top = (c.y - radius) + "px";
    c.inner.style.left = (c.x - innerRadius) + "px";
    c.inner.style.top = (c.y - innerRadius) + "px";
  });
}

function resizeCircles(factor) {
  radius *= factor;
  innerRadius *= factor;
  radius = Math.round(radius);
  innerRadius = Math.round(innerRadius);
  circles.flat().forEach(c => {
    c.outer.el.style.width = c.outer.el.style.height = radius * 2 + "px";
    c.outer.el.style.left = (c.x - radius) + "px";
    c.outer.el.style.top = (c.y - radius) + "px";
    c.inner.style.width = c.inner.style.height = innerRadius * 2 + "px";
    c.inner.style.left = (c.x - innerRadius) + "px";
    c.inner.style.top = (c.y - innerRadius) + "px";
  });
}

function resizeInnerCircles(factor) {
  innerRadius *= factor;
  circles.flat().forEach(c => {
    c.inner.style.width = c.inner.style.height = innerRadius * 2 + "px";
    c.inner.style.left = (c.x - innerRadius) + "px";
    c.inner.style.top = (c.y - innerRadius) + "px";
  });
}

document.getElementById("fileInput").onchange = (e) => {
  loadImageFromFile(e.target.files[0]);
};

function handleDrop(e) {
  e.preventDefault();
  const file = e.dataTransfer.files[0];
  if (file) loadImageFromFile(file);
}

container.addEventListener("dragover", (e) => e.preventDefault());
container.addEventListener("drop", handleDrop);

document.addEventListener("paste", (e) => {
  const items = e.clipboardData.items;
  for (let i = 0; i < items.length; i++) {
    if (items[i].type.indexOf("image") !== -1) {
      const blob = items[i].getAsFile();
      loadImageFromFile(blob);
    }
  }
});

function loadImageFromFile(file) {
  const reader = new FileReader();
  reader.onload = (e) => {
    img.onload = () => {
      resizeCanvasToImage();
      drawImage();
      clearCircles();
    };
    img.src = e.target.result;
  };
  reader.readAsDataURL(file);
}

function getGrayHist(x, y, radius) {
  x += 2
  y += 2
  const imgData = ctx.getImageData(x - radius, y - radius, radius * 2, radius * 2);
  const data = imgData.data;

  let sum = 0;
  let count = 0;
  let hist = [0,0,0,0,0,0,0,0,0,0];
  for (let j = 0; j < radius * 2; j++) {
    for (let i = 0; i < radius * 2; i++) {
      const dx = i - radius;
      const dy = j - radius;
      if (dx * dx + dy * dy <= radius * radius) {
        if (dx * dx + dy * dy >= innerRadius * innerRadius) {
          const idx = (j * radius * 2 + i) * 4;

          const r = data[idx];
          const g = data[idx + 1];
          const b = data[idx + 2];
          const gray = 0.299 * r + 0.587 * g + 0.114 * b;
          const grayIdx = Math.floor(gray/25.5)
          sum += gray;
          hist[grayIdx]++;
          count++;

          // Color this pixel red
          //data[idx] = 255;
          //data[idx + 1] = 0;
          //data[idx + 2] = 0;
        }
      }
    }
  }

  // Write modified image data back to canvas
  //ctx.putImageData(imgData, x - radius, y - radius);

  return hist;
}

function showGrayLevels() {
  let m = circles.length;
  let n = (m > 0) ? circles[0].length : 0;
  let result = "[\n";
  let excelResult = ""
  for (let i = 0; i < m; i++) {
    for (let j = 0; j < n; j++) {
      let x = circles[i][j].x;
      let y = circles[i][j].y;
      let grayHist = getGrayHist(x, y, radius);
      result += grayHist.join(',')+'\n';
      excelResult += grayHist.join('\t')+'\r\n';
    }
  }
  navigator.clipboard.writeText(excelResult).then(() => {
      alert('Table copied to clipboard! Paste into Excel.');
  }).catch(err => {
      console.error('Failed to copy:', err);
  });
  result += "\n]";
  document.getElementById("grayOutput").value = result;
}
</script>

</body>
</html>

